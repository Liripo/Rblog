---
title: "flametree学习"
author: "Liripo"
date: '2020-07-28'
slug: flametree学习
tags: R
summary: ' '
output:
  html_document:
    toc: true
    dev: 'svg'
    code_folding: "hide"
    highlight: textmate
    theme: flatly
---



<div id="flametree" class="section level1">
<h1>flametree</h1>
<p><a href="https://github.com/djnavarro/flametree">flametree</a>使用贝塞尔曲线绘制了很好看的树。</p>
<pre class="r"><code>library(tidyverse)
flametree::flametree_grow() %&gt;% flametree::flametree_plot()</code></pre>
<p><img src="/post/R/2020-07-28-flametree学习_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
</div>
<div id="learn-code" class="section level1">
<h1>learn code</h1>
<div id="flametree_plot" class="section level2">
<h2>flametree_plot</h2>
<pre class="r"><code>flametree::flametree_plot
## function (tree, background = &quot;antiquewhite4&quot;, palette = &quot;viridis::inferno&quot;) 
## {
##     mapping &lt;- ggplot2::aes(x = coord_x, y = coord_y, group = id_path, 
##         size = seg_wid, color = seg_col)
##     picture &lt;- ggplot2::ggplot(data = tree, mapping = mapping) + 
##         ggforce::geom_bezier2(show.legend = FALSE, lineend = &quot;round&quot;) + 
##         paletteer::scale_color_paletteer_c(palette = palette) + 
##         theme_mono(color = background)
##     return(picture)
## }
## &lt;bytecode: 0x000000001ace09d8&gt;
## &lt;environment: namespace:flametree&gt;</code></pre>
<p>绘图源代码中使用了<code>ggforce::geom_bezier2</code>函数去绘制图形，我在看这个函数的源代码时发现<code>StatBezier</code>在数据转换使用了一个<code>ggforce:::getBeziers</code>函数，没怎么看明白cpp代码，而且ggplot2的扩展我也还没怎么弄清。不过大概意思就是根据贝塞尔曲线生成一系列的点，然后使用geom_path绘制图形。</p>
<p>搜了下贝塞尔曲线是什么，参考了<a href="https://github.com/BooheeFE/weekly/issues/31">https://github.com/BooheeFE/weekly/issues/31</a>。</p>
<p>然后摸索了一下函数<code>flametree::flametree_grow()</code>生成的数据，它生成了每三个点为一组的数据。这里我们就看看前三行数据,就不用knitr输出整个表了</p>
<pre class="r"><code>flametree::flametree_grow() %&gt;% head(3)-&gt;data
data
## # A tibble: 3 x 10
##   coord_x coord_y seg_deg seg_len seg_col seg_wid id_time id_path id_step
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
## 1       0     0        90       1     0     0.905       1       1       0
## 2       0     0.5      90       1     0.5   0.905       1       1       1
## 3       0     1        90       1     1     0.905       1       1       2
## # ... with 1 more variable: id_leaf &lt;lgl&gt;</code></pre>
<p>试着按照参考的三个点的贝塞尔曲线写了个函数，当然推导过程我还没看看怎么推导的~~</p>
<pre class="r"><code>r_getbeziers &lt;- function(data,coordx,coord_y,n = 100){
  p_x &lt;-  data$coord_x 
  p_y &lt;- data$coord_y
  n_t &lt;- seq(0,1,length.out = n)
  outx &lt;- (1-n_t)^2*p_x[1] + 2*(1-n_t)*n_t*p_x[2] +n_t^2*p_x[3]
  outy &lt;- (1-n_t)^2*p_y[1] + 2*(1-n_t)*n_t*p_y[2] +n_t^2*p_y[3]
  out &lt;- tibble(x = outx , y = outy)
  out
}</code></pre>
<p>验证一下,</p>
<pre class="r"><code>data %&gt;% r_getbeziers(coordx,coord_y)-&gt;a
b &lt;- ggforce:::getBeziers(data$coord_x,data$coord_y,id = data$id_path,100)
all(b$paths == a)
## [1] TRUE</code></pre>
<p>贝塞尔曲线就到这吧。所以剩下一个绘制flametree树图的问题就是如何生成每三个点为一组的数据了,当然，按照<code>flametree::flametree_plot</code>函数所示，数据还需要加上线的大小以及颜色。</p>
</div>
<div id="flametree_grow" class="section level2">
<h2>flametree_grow</h2>
<pre class="r"><code>flametree::flametree_grow
## function (seed = 286, time = 6, scale = c(0.8, 0.9), angle = c(-10, 
##     10, 20), split = 2, prune = 0) 
## {
##     param &lt;- list(seed = seed, time = time, scale = scale, angle = angle, 
##         split = split, prune = prune)
##     set.seed(param$seed)
##     tree &lt;- grow_sapling() %&gt;% grow_tree(param) %&gt;% shape_tree()
##     tree$id_leaf &lt;- tree$id_time == max(tree$id_time)
##     return(tree)
## }
## &lt;bytecode: 0x0000000019d814a8&gt;
## &lt;environment: namespace:flametree&gt;</code></pre>
<p>这些参数，seed明显就是用来可重复的，time帮助文档说是迭代的次数，经过摸索，它是要生成多少次树枝，而split是生成的分枝个数，prune是修剪的概率。prune的实现原理是使用sample_n跟stats::rbinom实现的，可以看看<code>flametree:::grow_shoots</code>的代码，这里默认0是不修剪，暂时先不管它了。
看下time = 2,split = 1的图长什么样。</p>
<pre class="r"><code>flametree::flametree_grow(time = 2,split = 1,angle = 10,scale = 0.9) %&gt;% 
  flametree::flametree_plot()</code></pre>
<p><img src="/post/R/2020-07-28-flametree学习_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<div id="grow_sapling" class="section level3">
<h3>grow_sapling</h3>
<pre class="r"><code>flametree:::grow_sapling() %&gt;% print()
## # A tibble: 1 x 9
##     x_0   y_0   x_1   y_1   x_2   y_2 seg_deg seg_len id_time
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;
## 1     0     0     0   0.5     0     1      90       1       1</code></pre>
<p>可以看到生成一个初始tibble,<code>(x_0:y_2)</code>列是绘制贝塞尔曲线的三个点，经过<code>flametree:::shape_tree</code>函数最后转成长列表格式。seg_deg是生成的角度，现在可能不太好说明。seg_len是树枝的长度，id_time则是进行的迭代id。</p>
</div>
<div id="grow_tree" class="section level3">
<h3>grow_tree</h3>
<pre class="r"><code>flametree:::grow_tree
## function (sapling, param) 
## {
##     tree &lt;- purrr::accumulate(.x = 1:param$time, .f = grow_layer, 
##         .init = sapling, param = param)
##     return(tree)
## }
## &lt;bytecode: 0x000000001a0f65d0&gt;
## &lt;environment: namespace:flametree&gt;</code></pre>
<p>可以看到，.init参数是sapling,即生成的数据框列表第一个是sapling,之后进行迭代。
花了挺久时间才明白.init参数是什么作用。</p>
</div>
<div id="grow_layer" class="section level3">
<h3>grow_layer</h3>
<pre class="r"><code>flametree:::grow_layer
## function (shoots, time, param) 
## {
##     new_shoots &lt;- purrr::map_dfr(.x = 1:param$split, .f = grow_shoots, 
##         shoots = shoots, param = param)
##     return(new_shoots)
## }
## &lt;bytecode: 0x000000001a106738&gt;
## &lt;environment: namespace:flametree&gt;</code></pre>
<p>可以看到split参数就是用来生成多少行的数据框的，
先看下grow_shoots源码，</p>
<pre class="r"><code>flametree:::grow_shoots
## function (time, shoots, param) 
## {
##     n_shoots &lt;- nrow(shoots)
##     n_pruned &lt;- stats::rbinom(n = 1, size = n_shoots - 1, prob = param$prune)
##     ch_seg_len &lt;- sample(x = param$scale, size = n_shoots, replace = TRUE)
##     ch_seg_deg &lt;- sample(x = param$angle, size = n_shoots, replace = TRUE)
##     shoots &lt;- shoots %&gt;% dplyr::mutate(x_0 = x_2, y_0 = y_2, 
##         seg_len = seg_len * ch_seg_len, x_1 = x_0 + extend_x(seg_len/2, 
##             seg_deg), y_1 = y_0 + extend_y(seg_len/2, seg_deg), 
##         seg_deg = seg_deg + ch_seg_deg, id_time = id_time + 1L, 
##         x_2 = x_0 + extend_x(seg_len, seg_deg), y_2 = y_0 + extend_y(seg_len, 
##             seg_deg), ) %&gt;% dplyr::sample_n(size = n_shoots - 
##         n_pruned)
##     return(shoots)
## }
## &lt;bytecode: 0x000000001a14cef0&gt;
## &lt;environment: namespace:flametree&gt;</code></pre>
<p>time参数并没有在grow_shoots使用到。所以当用1:param$split为time参数，且默认split为2时,生成的点是有可能跟原来重复的。也就是有的地方geom_path会绘制多次。验证一下，</p>
<pre class="r"><code>flametree::flametree_grow()-&gt;a
a %&gt;% filter(id_time == 7) %&gt;% nrow()
## [1] 192
a %&gt;% filter(id_time == 7) %&gt;% select(-id_path) %&gt;% 
  distinct() %&gt;% nrow()
## [1] 171</code></pre>
<p>可以看到有些行数被去重了。（应该是这样的）
&gt;这儿是不是应该修改成split的两个不会重复呢？(虽然这样想，我还没试着改下)</p>
<pre class="r"><code>flametree::flametree_grow(seed = 100) %&gt;% flametree::flametree_plot()</code></pre>
<p><img src="/post/R/2020-07-28-flametree学习_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>这个图很显然就是第一个枝桠没有生出两个分支的例子了。
&gt;备注：重新看下作者的帮助文档，她也说了split是生成最大的分支的意思（怪我一开始没理解这参数的意思）</p>
</div>
<div id="grow_shoots" class="section level3">
<h3>grow_shoots</h3>
<p>这个函数源码正如上所示，
起始的shoots为sapling,即</p>
<pre class="r"><code>sapling &lt;- flametree:::grow_sapling()
shoots &lt;- sapling</code></pre>
<p>然后这个函数代码中，第三第四行分别scale,angle的随机数，默认参数的随机选择比较少些,试下参数改成scale= runif(100,0.8,0.9)。</p>
<pre class="r"><code>flametree::flametree_grow(seed= 100,scale = runif(100,0.6,0.9)) %&gt;% 
  flametree::flametree_plot()</code></pre>
<p><img src="/post/R/2020-07-28-flametree学习_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>hh,有必要么。。。</p>
<p>接着看下最后的操作，下一个生成的shoots会是啥，这里我们用参数split = 1来看看，就是函数<code>accumulate</code>累加生成的shoots都为1行。如果按照默认参数time = 6,split = 2的话，起始shoots为一行，之后变<code>1*2</code>行，<code>1*2*2</code>行,…<code>1*2^6</code>行。</p>
<pre class="r"><code>shoots &lt;- shoots %&gt;% dplyr::mutate(
  x_0 = x_2, 
  y_0 = y_2, 
  seg_len = seg_len * ch_seg_len, 
  x_1 = x_0 + extend_x(seg_len/2,seg_deg), 
  y_1 = y_0 + extend_y(seg_len/2, seg_deg), 
  seg_deg = seg_deg + ch_seg_deg, 
  id_time = id_time + 1L, 
  x_2 = x_0 + extend_x(seg_len, seg_deg), 
  y_2 = y_0 + extend_y(seg_len, seg_deg),)</code></pre>
<p>可以看到，p0第一个点，p1第二个点，p2第三个点，新的shoots的p0是上一个shoots的p2,seg_len跟seg_deg就是新生成的shoots长度跟角度的修改。</p>
<pre class="r"><code>flametree:::extend_x
## function (distance, angle) 
## {
##     distance * cos(radians(angle))
## }
## &lt;bytecode: 0x000000001aeec5f8&gt;
## &lt;environment: namespace:flametree&gt;
flametree:::radians
## function (degree) 
## {
##     2 * pi * degree/360
## }
## &lt;bytecode: 0x000000001aeeb910&gt;
## &lt;environment: namespace:flametree&gt;</code></pre>
<p>然后p1点的延伸使用的是新的shoots的长度跟原来的shoots的角度,p2点的延伸使用新的shoots的长度与角度生成。（为什么不都使用新的长度跟角度呢）</p>
<p>所以假设ch_seg_len = 0.9,ch_seg = 10的话,新的shoots即为，</p>
<pre><code># A tibble: 1 x 9
    x_0   y_0      x_1   y_1    x_2   y_2 seg_deg seg_len id_time
  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;
1     0     1 2.76e-17  1.45 -0.156  1.89     100     0.9       2</code></pre>
</div>
</div>
</div>
<div id="last" class="section level1">
<h1>last</h1>
<p>总的差不多就是这样了,之后对grow_tree的数据转成长数据就行了。
作者在github上绘制的图</p>
<pre class="r"><code>flametree::flametree_grow(seed = 4, time = 13) %&gt;% 
  flametree::flametree_plot()</code></pre>
<p><img src="/post/R/2020-07-28-flametree学习_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
</div>
